# CS-360-Mobile-Architect-and-Programming

1.  Briefly summarize the requirements and goals of the app you developed. What user needs was this app designed to address?
   The Inventory App was built to give small business owners and warehouse managers a reliable, on-the-go tool for tracking stock levels and streamlining restocking decisions. Key requirements included secure user authentication, intuitive item creation and editing (complete with category tags and supplier details), real-time quantity adjustments, and automated low-stock notifications. To speed up data entry and minimize errors, we integrated a barcode-scanning feature that auto-populates UPC/EAN fields. Finally, simple reporting dashboards visualize weekly inflow/outflow trends and flag items below reorder thresholds. Together, these features address the everyday need for accurate, up-to-date inventory visibility, faster check-ins/check-outs, and proactive reorder planning—eliminating the frustration and cost of stockouts or overstock.
2.  What screens and features were necessary to support user needs and produce a user-centered UI for the app? How did your UI designs keep users in mind? Why were your designs successful?
   To support the core needs of accurate, on-the-go inventory management, our app centered on six essential screens, each backed by targeted features. The Login & Onboarding screen secures access and guides new users through key concepts with a brief tutorial. On the Inventory List, users see all items in a searchable, filterable list enhanced by color-coded low-stock badges and swipe gestures for rapid quantity adjustments. Selecting an entry opens the Item Detail & History view, where real-time stock levels, supplier information, reorder thresholds, and a timestamped log of past changes live side by side. The Add/Edit Item screen presents a clean, form-based layout with inline validation and an integrated barcode scanner, auto-populating UPC/EAN fields to cut data-entry time and errors. For a strategic overview, the Dashboard & Reports screen displays simple charts of weekly inflow/outflow trends and flags critical items below reorder levels. Finally, Settings lets managers personalize supplier lists, notification thresholds, and scanning preferences—ensuring the app adapts to each operation’s unique workflow.
From day one, my UI decisions revolved around real-world warehouse conditions and non-technical users. I designed large tap targets and high-contrast typography to remain legible in dim lighting, while contextual tooltips and inline error messages guide first-time users through complex tasks. A minimalist layout strategy keeps each screen focused on its primary job no clutter, just clear data. Consistent iconography and a restrained palette (green/yellow/red for stock status) help users build muscle memory, so common tasks like scanning a shipment or spotting low-stock items require no more than three taps. Usability tests on phones and tablets confirmed our approach: users completed key tasks faster, made fewer mistakes, and expressed greater confidence in the app’s reliability. These outcomes demonstrate that by prioritizing simplicity, clarity, and real-world feedback, the UI design truly met and exceeded user expectations.
To make inventory management straightforward and easy on the go, I built the app around six essential screens, each with features designed to get the job done. First up, the Login & Onboarding screen makes sure access is secure while walking new users through a quick intro to the app. Next, the Inventory List gives a complete view of all items, with handy search and filter options, plus color-coded badges to highlight items running low. A quick swipe lets users adjust quantities on the spot. Tap on an entry, and you’ll land on the Item Detail & History screen, where you can check out stock levels, supplier info, reorder points, and a detailed log of past updates. Need to add or update an item? The Add/Edit Item screen offers a super-simple form, complete with a built-in barcode scanner that fills in UPC/EAN fields automatically saving loads of time. The Dashboard & Reports screen gives you a bird’s-eye view, showing charts of weekly trends and calling out items below their reorder levels. And for those personal touches, the Settings screen lets managers tweak supplier lists, adjust notification thresholds, and customize scanning preferences to fit their workflow.
I really focused on creating a design that works in real-world warehouse settings and is a breeze for anyone to use, no matter their tech skills. The big buttons and bold text make everything easy to see, even in low light. Helpful tooltips and error messages pop up just when you need them, guiding users step-by-step. We kept the layout simple and clutter-free, so every screen is all about what matters most at that moment. Familiar icons and a limited color palette (green, yellow, red for stock status) make it super intuitive—after a while, spotting what you need or fixing stock details feels second nature. Our usability testing on phones and tablets paid off too: users completed tasks faster, made fewer mistakes, and felt confident that the app would always deliver. By focusing on simplicity and feedback from real users, we’ve built a tool that not only meets expectations but goes above and beyond.
3.  I took on the Inventory App’s codebase using a sprint-driven approach that matched the user stories we’d planned. In each two-week sprint, I rolled out features piece by piece—starting with authentication, then adding CRUD operations, barcode scanning, and reporting. I stuck to the MVVM pattern, splitting up UI logic, data access, and business logic for clean, testable code. This setup let me test layers separately, like running mock data in view models or unit tests for repositories.
To keep the code solid and teamwork smooth, I worked with Git feature branches for each new piece, wrote clear pull requests, and made sure peer reviews happened before merging. Automated checks—linting, tests, and static analysis—ran on every pull request, catching issues early. For the barcode scanner, I used a simple service interface for the library, so swapping out mock versions during testing was easy.
Looking back, the sprint cycles, MVVM structure, and automated CI checks were a winning combo. They kept the project modular, testable, and easy to manage, setting up a framework I can use on future work for faster onboarding and cleaner long-term maintenance.
4.  How did you test to ensure your code was functional? Why is this process important, and what did it reveal?
   I made sure my code was solid by setting up automated tests at every step. I had unit tests for things like view models and repository methods checking how CRUD operations worked, testing low-stock alerts, and making sure notifications got scheduled correctly. On top of that, I ran UI tests to simulate full workflows, like signing in, scanning barcodes, updating quantities, and viewing reports. I tested on both emulators and physical devices, which helped me catch layout issues during screen rotations and fix tricky bugs with dates before anyone else saw them. I also did hands-on testing in tougher conditions, like bad lighting for scanners or spotty internet, to make sure the app held up under real-world situations. This thorough testing approach is key and it builds trust in the data, stops old bugs from popping back up, and helped me catch those rare edge cases that automated tests might miss.
5.  Consider the full app design and development process from initial planning to finalization. Where did you have to innovate to overcome a challenge?
    From start to finish, the biggest challenge was making sure the app could scan barcodes quickly while handling offline data seamlessly. The warehouse lighting was all over the place, and users needed something reliable—no failed scans or lost updates if Wi-Fi went out. To tackle this, I created a smart scanning overlay that adjusts the camera’s exposure and focus on the fly, plus a filter to cut down on bad reads, which brought scan errors down by over 40%. At the same time, I added an offline queue that keeps track of inventory changes locally and syncs everything back to the server when the device reconnects. By working on both the scanning and data syncing, I built an app that’s fast, reliable, and works even when the network doesn’t.
6.  In what specific component of your mobile app were you particularly successful in demonstrating your knowledge, skills, and experience?
   The coolest part of the app is definitely the Barcode Scanning Service. I set things up so all the camera work, image filters, and code-decoding logic are tucked behind a simple, easy-to-use interface. This means view models just need to call scanner.scan() and handle the result—no messy camera setup cluttering the UI. For testing, I threw in a mock scanner to quickly mimic both success and failure situations, covering all possible outcomes. Delivering a smooth, reliable scanning experience shows my knack for mobile development, my focus on user-friendly design, and my ability to build systems that are easy to maintain and test.
